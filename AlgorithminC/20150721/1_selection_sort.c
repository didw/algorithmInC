// 1_selection_sort.c

// 알고리즘과 자료구조의 상관관계
// 문제를 해결할 때, '무엇을 어떻게 해라'라고하는 것은
// '무엇' - 자료구조
// '어떻게' - 알고리즘

// "흰자와 노른자의 관계"
// 한정된 공간 안에서 노른자가 크면 흰자가 줄어들어야 하고,
// 흰자가 크면 노른자가 줄어 들어야 한다.
// 자료구조가 복잡하면 알고리즘은 간결해지고,
// 자료구조가 간결하면 알고리즘은 복잡해진다.

// 트레이트 오프 - 한 쪽을 위해서 다른 한 쪽이 희생해야 하는 것
// 성능을 빠르게 하려면, 메모리를 많이 사용해야 하고
// 메모리를 작게 사용하려면, 성능을 적당한 수준으로 맞춰야 한다.

// 알고리즘의 시간 복잡도를 가장 잘 표현하는 것이 정렬과 탐색 알고리즘이다.
// 정렬 알고리즘
// 임의의 순서대로 배열이 되어 있는 자료의 집합을 일정한 순서대로 재배열 하는 것
// 오름차순 또는 내림차순
// 선택정렬, 삽입정렬, 버블정렬, 퀵정렬, 힙정렬

// 정렬 알고리즘의 구성 요소
// 1. 판단(decision)
// 2. 교환(exchange)
// 정렬 알고리즘의 안정성
// 같은 내용을 가지는 키값일 경우, 정렬 후에도 그 순서가 변하지 않을 때 안정성 있다고 얘기한다.
// 그 순서가 유지되지 않으면 안정성이 없다고 한다.

// 선택정렬
// 알고리즘
// 최소값을 찾아서 데이터 영역의 가장 앞으로 이동하는 방식으로 반복하여 정렬하는 알고리즘
// 개요
// 1. 1~n번 내의 가장 작은 숫자를 찾는다.
// 2. 그 숫자를 원래 1번과 바꿔친다.
// 3. 2~n번 내의 가장 작은 숫자를 찾는다.
// 4. 그 숫자를 원래 2번과 바꿔친다.
// 5. 이런 식으로 k번~n번 내의 가장 작은 숫자를 찾아서 원래 k번과 바꿔친다.

// 알고리즘
// 1. i = 0;
// 2. i < n-1 되면 끝난다.
// 3. i항부터 n-1항까지 최소값을 min값에 보관한다.
// 4. i항을 min항과 교환한다.

#include "algorithm.h"
// O(n^2)
void selection_sort(int *a, int n)
{
	int i, j, min;
	for (i = 0; i < n - 1; i++)
	{
		min = i;
		for (j = i + 1; j < n; j++)
		{
			if (a[min] > a[j])
				min = j;
		}
		swap(&a[min], &a[i]);
	}
}

#if 0
int main()
{
	int a[] = { 9, 1, 6, 8, 4, 3, 2, 0 };
	int n = sizeof(a) / sizeof(a[0]);
	// 선택 정렬 실행
	selection_sort(a, n);
	// 배열 출력 함수
	print_array(a, n);
}
#endif

int main()
{
	prepare_sample_datas();
	start_timer();
	selection_sort(reverse_data_100000, 100000);
	end_timer();
}